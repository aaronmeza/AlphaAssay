apiVersion: v1
kind: Namespace
metadata: { name: kube-system }
---
apiVersion: v1
kind: ServiceAccount
metadata: { name: metrics-server, namespace: kube-system }
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: system:aggregated-metrics-reader
  labels:
    rbac.authorization.k8s.io/aggregate-to-view: "true"
    rbac.authorization.k8s.io/aggregate-to-edit: "true"
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
rules:
- apiGroups: ["metrics.k8s.io"]
  resources: ["pods", "nodes"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata: { name: system:metrics-server }
rules:
- apiGroups: [""]
  resources: ["nodes/metrics", "pods", "nodes"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["extensions"]
  resources: ["replicasets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["replicasets"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["nodes/proxy"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["authentication.k8s.io"]
  resources: ["tokenreviews"]
  verbs: ["create"]
- apiGroups: ["authorization.k8s.io"]
  resources: ["subjectaccessreviews"]
  verbs: ["create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata: { name: metrics-server:system:auth-delegator }
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: metrics-server
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata: { name: metrics-server-auth-reader, namespace: kube-system }
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: extension-apiserver-authentication-reader
subjects:
- kind: ServiceAccount
  name: metrics-server
  namespace: kube-system
---
apiVersion: v1
kind: Service
metadata: { name: metrics-server, namespace: kube-system, labels: { k8s-app: metrics-server } }
spec:
  selector: { k8s-app: metrics-server }
  ports:
  - name: https
    port: 443
    targetPort: 4443
---
apiVersion: apps/v1
kind: Deployment
metadata: { name: metrics-server, namespace: kube-system, labels: { k8s-app: metrics-server } }
spec:
  selector: { matchLabels: { k8s-app: metrics-server } }
  replicas: 1
  template:
    metadata: { labels: { k8s-app: metrics-server } }
    spec:
      priorityClassName: system-cluster-critical
      serviceAccountName: metrics-server
      nodeSelector: { kubernetes.io/os: linux }
      tolerations:
      - { key: "node-role.kubernetes.io/master", operator: "Exists", effect: "NoSchedule" }
      - { key: "node-role.kubernetes.io/control-plane", operator: "Exists", effect: "NoSchedule" }
      containers:
      - name: metrics-server
        image: registry.k8s.io/metrics-server/metrics-server:v0.7.1
        imagePullPolicy: IfNotPresent
        args:
          - --cert-dir=/tmp
          - --secure-port=4443
          - --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalIP,ExternalDNS
          - --kubelet-use-node-status-port
          - --metric-resolution=15s
          # - --kubelet-insecure-tls
        ports: [ { name: https, containerPort: 4443, protocol: TCP } ]
        livenessProbe:
          httpGet: { path: /livez, port: https, scheme: HTTPS }
          initialDelaySeconds: 20
          periodSeconds: 10
        readinessProbe:
          httpGet: { path: /readyz, port: https, scheme: HTTPS }
          initialDelaySeconds: 20
          periodSeconds: 10
        resources: { requests: { cpu: 50m, memory: 100Mi } }
---
apiVersion: apiregistration.k8s.io/v1
kind: APIService
metadata: { name: v1beta1.metrics.k8s.io }
spec:
  service: { name: metrics-server, namespace: kube-system }
  group: metrics.k8s.io
  version: v1beta1
  insecureSkipTLSVerify: true
  groupPriorityMinimum: 100
  versionPriority: 100